use16	
org 100h ; 



;MAIN===========================================================================

lea si, [array] ;передаем в si ссылку на первый элемент массива
mov bx, 0      ;счетчик для прохода по массиву
xor cx, cx      ;счётчик для красивого вывода

mov di, AZ ;размер массива такой-то
call print_str
mov ax, [n]
call print_word_sdec
call print_endline
call print_endline     ;второй перенос для красоты

INPUT_CYCLE:

mov di, i_word ;для ввода (строка "введите число")
call print_str

inc cx                  ;костыль для корректного
mov ax, cx              ;вывода номера числа

call print_word_sdec		;вызываем вывод числа на экран
call print_endline      ;перенос строки
mov al, [buffer]        ;поправляем буфер
call input_str          ;вводим число
call str_to_sdec_word   ;переводим в число из строки
mov [si + bx], ax       ;сразу записываем в массив
call print_word_sdec    ;выводим это число просто чтобы было
call print_endline      ;перенос строки

add bx, 2		
cmp cx, 10		
jz CONT
jmp INPUT_CYCLE

CONT:
mov bx, 0
call print_endline  

MAIN_CYCLE:	;основной цикл проходящий массив
	     mov cx,  [si + bx]	  
	     cmp cx, 0	     
	     jge NEXT	      ;если больше 0 - следующий элемент
	     cmp cx, 0
	     jle CHECK	       ;если меньше - проверка на нечётность

	     NEXT:	     ;возврат из проверок
	     add bx, 2		
	     cmp bx, 10 * 2		 ;так надо, чтобы было ограничение по длинне массива
	     jz PEND		    
jmp MAIN_CYCLE			   

CHECK:
  call check_odd
jmp NEXT

PEND:

mov ax, [res]
mov cx, print_str		;записываем адрес функции в cx  (без этого ничего не работает)

mov bx, print_endline		;записываем адрес функции вывода конца строки в регистр bx (без этого ничего не работает)

mov di, s_word			;записываем начало строки с выводом в регистр di
call cx 			;вызываем вывод начала строки 'Answer = ' 
call print_word_sdec		;вызываем вывод числа на экран
call bx 			;вызываем вывод конца строки '$'

mov di, s_pak
call cx
mov ah, 08h				;блок вызова оператора ввода для того чтобы программа не закрывалась сразу после выполнения
int 21h

mov ax, 4C00h				;завершаем программу
int 21h


;IMPLEMENTATION=================================================================

;Функция - складывает получившиеся части числа после деления в регистр Di и завершвет строку знаком $
;выход : di - строка со словом
print_word_sdec:		
	push di 			;запись состояния di
	mov di, buffer			;записываем в di из buffer макс. размерность строки указана в разделе var
	push di
	call word_to_sdec_str		;определение знака и так далее
	mov byte[di], '$'		;завершаем строку
	pop di
	call print_str			;выводим строку
	pop di				;восстановление di
ret

 
;Функция - определяет знак числа и в зависимости от этого добавляет в начало строки знак -
;вход : ax - число
;вход : di - строка для числа с "-" в начале
word_to_sdec_str:
	push ax
	test ax, ax
	jns wtsds_no_sign
	mov byte[di], '-'
	inc di
	neg ax

  
;Функция на случай если число не больше нуля/поставлен знак минуса
wtsds_no_sign:
	call word_to_udec_str
	pop ax
ret


  
;Перевод числа в строку в десятичном виде
;вход ax, bx, cx, dx - регимстры, которые освободятся в другой процедуре
word_to_udec_str:
	push ax 	;сохраняем регистры в стек
	push cx
	push dx
	push bx
	xor cx, cx	
	mov bx, 10
 
;Цикл получения остатков от деления
wtuds_lp1:
	xor dx, dx	;обнуление старшей части двойного слова
	div bx		;ax = (dx:ax)/bx, остаток в dx
	add dl, '0'	;преобразование остатка в код символа
	push dx 	;сохранение в стеке
	inc cx		;увеличиваем счетчик символов
	test ax, ax	;проверка ax
	jnz wtuds_lp1	;переход к началу цикла если частное не = 0
 
;Извлечение символов из стека
;выход : bx, dx, cx, ax - рабочие регистры, записанные ранее в стек
wtuds_lp2:
	pop dx		;восстановление символа из стека
	mov [di], dl	;сохранение символа в буффера
	inc di		;инкремент адреса буффера
	loop wtuds_lp2	;цикл

	pop bx ;восстанавливаем рабочие регистры
	pop dx
	pop cx
	pop ax
  
ret
 
;Процедура ввода строки c консоли
;вход : al - максимальная длина (c концом строки) (1 <= al <= buffer)
;выход : al - длина введённой строки (не считая символа $), dx - адрес строки, заканчивающейся символом $
input_str:
    push cx                 ;сохранение cx
    mov cx,ax               ;сохранение ax в cx
    mov ah, 0Ah
    mov [buffer],al         ;запись максимальной длины в первый байт буфера
    mov byte[buffer+1],0    ;обнуление второго байта (фактической длины)
    mov dx,buffer           ;aдрес буфера
    int 21h                
    mov al,[buffer+1]       ;длина введённой строки
    add dx,2                ;адрес строки
    mov ah,ch               ;восстановление ah
    pop cx                  ;восстановление cx
ret

;Процедура преобразования десятичной строки в слово со знаком
;вход : al - длина строки, dx - адрес строки, заканчивающейся символом CR(0Dh)
;выход : ax - слово (в случае ошибки ax = 0)
;cf = 1 - ошибка
str_to_sdec_word:
    push bx                 ;Сохранение регистров
    push dx
 
    test al,al              ;Проверка длины строки
    jz stsdw_error          ;Если равно 0, возвращаем ошибку
    mov bx,dx               ;BX = адрес строки
    mov bl,[bx]             ;BL = первый символ строки
    cmp bl,'-'              ;Сравнение первого символа с '-'
    jne stsdw_no_sign       ;Если не равно, то преобразуем как число без знака
    inc dx                  ;Инкремент адреса строки
    dec al                  ;Декремент длины строки
stsdw_no_sign:
    call str_to_udec_word   ;Преобразуем строку в слово без знака
    jc stsdw_exit           ;Если ошибка, то возвращаем ошибку
    cmp bl,'-'              ;Снова проверяем знак
    jne stsdw_plus          ;Если первый символ не '-', то число положительное
    cmp ax,32768            ;Модуль отрицательного числа должен быть не больше 32768
    ja stsdw_error          ;Если больше (без знака), возвращаем ошибку
    neg ax                  ;Инвертируем число
    jmp stsdw_ok            ;Переход к нормальному завершению процедуры
stsdw_plus:
    cmp ax,32767            ;Положительное число должно быть не больше 32767
    ja stsdw_error          ;Если больше (без знака), возвращаем ошибку
 
stsdw_ok:
    clc                     ;CF = 0
    jmp stsdw_exit          ;Переход к выходу из процедуры
stsdw_error:
    xor ax,ax               ;AX = 0
    stc                     ;CF = 1 (Возвращаем ошибку
stsdw_exit:
    pop dx                  ;Восстановление регистров
    pop bx
ret
 
;Процедура преобразования десятичной строки в слово без знака
;вход : al - длина строки, dx - адрес строки, заканчивающейся символом конца строки
;выход : ax - слово (в случае ошибки ax = 0)
;cf = 1 - ошибка

str_to_udec_word:
    push cx                 ;Сохранение всех используемых регистров
    push dx
    push bx
    push si
    push di
 
    mov si,dx               ;si = адрес строки
    mov di,10               ;di = множитель 10 (основание системы счисления)
    movzx cx,al             ;cx = счётчик цикла = длина строки
    jcxz studw_error        ;Если длина = 0, возвращаем ошибку
    xor ax,ax               ;ax = 0
    xor bx,bx               ;bx = 0
 
studw_lp:
    mov bl,[si]             ;Загрузка bl очередного символа строки
    inc si                  ;Инкремент адреса
    cmp bl,'0'              ;Если код символа меньше кода '0'
    jl studw_error          ;возвращаем ошибку
    cmp bl,'9'              ;Если код символа больше кода '9'
    jg studw_error          ;возвращаем ошибку
    sub bl,'0'              ;Преобразование символа-цифры в число
    mul di                  ;ax = ax * 10
    jc studw_error          ;Если результат больше 16 бит - ошибка
    add ax,bx               ;Прибавляем цифру
    jc studw_error          ;Если переполнение - ошибка
    loop studw_lp           ;Команда цикла
    jmp studw_exit          ;Успешное завершение (cf = 0)
 
studw_error:
    xor ax,ax               ;AX = 0
    stc                     ;CF = 1 (Возвращаем ошибку)
 
studw_exit:
    pop di                  ;Восстановление регистров
    pop si
    pop bx
    pop dx
    pop cx
ret 
    
;Процедура вывод строки на консоль
;вход : di - число строкой
print_str:
	push ax 	;сохраняем значение
	mov ah,09h	;вывод строки
	xchg dx, di	;обмен значений между DI, где хранится наше число и DX, через который мы выводим строку
	int 21h 	;прерываение
	xchg dx, di	;обмен значений между DI, где хранится наше число и DX, через который мы выводим строку
	pop ax		;восстанавливаем значение
ret

;Процедура переноса строки
print_endline:
	push di 	
	mov di, endline 
	call print_str		;вывод строки на консоль
	pop di
  
ret
  
 
 
;VAR============================================================================

array dw 10 dup(?) ;рабочий массив
res dw 0 ;для результата

s_pak db 'Press any key...$'		
s_word db 'Answer : $'
i_word db 'Input into array number $'			
endline db 13,10,'$'			;конец строки
buffer rb 7				;буфер на 6 символов для числа (если указать больше 128, всё сломается) 
AZ db 'Array size : $'

n dw 10 ;размер массива


;???============================================================================

;Суммирование (здесь, потому что иначе не работает :| )
sum:

add [res], cx

jmp NEXT

;Проверка на нечётность (ей уже здесь быть не обязательно)
check_odd:

 push ax
 push cx
 push dx
 
 mov dl, 2
 mov ax, cx
 idiv dl  ;можно было по крайнему правому биту проверять, ну да ладно
 cmp ah, 0
   
 jnz sum
  
 pop dx
 pop cx
 pop ax
  
ret
